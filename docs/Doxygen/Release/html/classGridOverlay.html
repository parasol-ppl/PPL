<!-- HTML header for doxygen 1.8.4-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.3"/>
<title>PMPL: GridOverlay Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
  <div id="titlearea">
    <table cellspacing="10" cellpadding="10">
      <tr style="height: 56px; text-align: center;">
        <th>PMPL API Reference</th>
        <td>
          <table cellspacing="10" cellpadding="10">
            <tr>
              <td><a class="qindex" href="index.html">Overview</a></td>
              <td><a class="qindex" href="group__Core.html">Core</a></td>
              <td><a class="qindex" href="group__AlgorithmAbstractions.html">Algorithm Abstractions</a></td>
              <td><a class="qindex" href="group__Utilities.html">Utilities</a></td>
              <td><a class="qindex" href="group__ParallelMethods.html">Parallel Methods</a></td>
            </tr>
            <tr>
              <td><a class="qindex" href="modules.html">Modules</a></td>
              <td><a class="qindex" href="inherits.html">Class Hierarchy</a></td>
              <td><a class="qindex" href="annotated.html">Classes</a></td>
              <td><a class="qindex" href="functions.html">Functions</a></td>
            </tr>
            <tr>
              <td><a class="el" href="todo.html" target="_self">Todo List</a></td>
              <td><a class="el" href="bug.html" target="_self">Bug List</a></td>
              <td><a class="qindex" href="group__DeadCode.html">Dead Code</a></td>
            </tr>
          </table>
        </td>
        <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.svg"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
      </tr>
    </table>
  </div>
  <!-- end header part -->
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="classGridOverlay-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">GridOverlay Class Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Construction</div></td></tr>
<tr class="memitem:a51afef65aa767d4229438d8b2ff2a655"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGridOverlay.html#a51afef65aa767d4229438d8b2ff2a655">GridOverlay</a> (const <a class="el" href="classBoundary.html">Boundary</a> *const _b, const double _length)</td></tr>
<tr class="separator:a51afef65aa767d4229438d8b2ff2a655"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0ba4f5415c77a978084d5e12f896261"><td class="memItemLeft" align="right" valign="top"><a id="ad0ba4f5415c77a978084d5e12f896261" name="ad0ba4f5415c77a978084d5e12f896261"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>~GridOverlay</b> () noexcept</td></tr>
<tr class="separator:ad0ba4f5415c77a978084d5e12f896261"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Cell Finders</div></td></tr>
<tr class="memitem:aaf5a20d3e8ad1e8a5d43764a1c3535c8"><td class="memItemLeft" align="right" valign="top"><a id="aaf5a20d3e8ad1e8a5d43764a1c3535c8" name="aaf5a20d3e8ad1e8a5d43764a1c3535c8"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>Size</b> () const noexcept</td></tr>
<tr class="memdesc:aaf5a20d3e8ad1e8a5d43764a1c3535c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of cells in the grid. <br /></td></tr>
<tr class="separator:aaf5a20d3e8ad1e8a5d43764a1c3535c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdba9adc448be3a77dfa1d3bb33e5366"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGridOverlay.html#abdba9adc448be3a77dfa1d3bb33e5366">Size</a> (const size_t _i) const noexcept</td></tr>
<tr class="separator:abdba9adc448be3a77dfa1d3bb33e5366"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40e6ec21ca468c2aea5d8c6d04f1fe1d"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGridOverlay.html#a40e6ec21ca468c2aea5d8c6d04f1fe1d">LocateCell</a> (const <a class="el" href="classCfg.html">Cfg</a> &amp;_cfg) const</td></tr>
<tr class="separator:a40e6ec21ca468c2aea5d8c6d04f1fe1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa819183185181c09f434f8ed17da6e33"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGridOverlay.html#aa819183185181c09f434f8ed17da6e33">LocateCell</a> (const Point3d &amp;_p) const</td></tr>
<tr class="separator:aa819183185181c09f434f8ed17da6e33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a245056ab21132e5b6151b2522fafd126"><td class="memItemLeft" align="right" valign="top">std::unordered_set&lt; size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGridOverlay.html#a245056ab21132e5b6151b2522fafd126">LocateCells</a> (const <a class="el" href="classBoundary.html">Boundary</a> *const _b, const <a class="el" href="classGridOverlay.html#afcf6fc05b418b5123c9bc28012505400">CellSet</a> _type=CellSet::Closure) const</td></tr>
<tr class="separator:a245056ab21132e5b6151b2522fafd126"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b009d33707877f4e4e716819d9f8ffe"><td class="memItemLeft" align="right" valign="top">std::unordered_set&lt; size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGridOverlay.html#a5b009d33707877f4e4e716819d9f8ffe">LocateCells</a> (const <a class="el" href="classGMSPolyhedron.html">GMSPolyhedron</a> &amp;_polyhedron, const mathtool::Transformation &amp;_transformation={}, const <a class="el" href="classGridOverlay.html#afcf6fc05b418b5123c9bc28012505400">CellSet</a> _type=CellSet::Closure) const</td></tr>
<tr class="separator:a5b009d33707877f4e4e716819d9f8ffe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b4fac7a1e567afec6dd680f94259066"><td class="memItemLeft" align="right" valign="top">std::unordered_set&lt; size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGridOverlay.html#a1b4fac7a1e567afec6dd680f94259066">LocateBBXCells</a> (const <a class="el" href="classBoundary.html">Boundary</a> *const _b) const</td></tr>
<tr class="separator:a1b4fac7a1e567afec6dd680f94259066"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2715d2da1ea89d584d6d3156a2429461"><td class="memItemLeft" align="right" valign="top">std::unordered_set&lt; size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGridOverlay.html#a2715d2da1ea89d584d6d3156a2429461">LocateBBXCells</a> (const Point3d &amp;_min, const Point3d &amp;_max) const</td></tr>
<tr class="separator:a2715d2da1ea89d584d6d3156a2429461"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00b19b87196fbfd7c8bc1640b59a6644"><td class="memItemLeft" align="right" valign="top">std::unordered_set&lt; size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGridOverlay.html#a00b19b87196fbfd7c8bc1640b59a6644">LocateFacetNeighbors</a> (const size_t _index) const</td></tr>
<tr class="separator:a00b19b87196fbfd7c8bc1640b59a6644"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4119b768dc1ca2cd9fcb5ff9fecaddee"><td class="memItemLeft" align="right" valign="top">std::unordered_set&lt; size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGridOverlay.html#a4119b768dc1ca2cd9fcb5ff9fecaddee">LocateEdgeNeighbors</a> (const size_t _index) const</td></tr>
<tr class="separator:a4119b768dc1ca2cd9fcb5ff9fecaddee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3de4712a6837b0cb9e72b23be9957eb0"><td class="memItemLeft" align="right" valign="top">std::unordered_set&lt; size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGridOverlay.html#a3de4712a6837b0cb9e72b23be9957eb0">LocateVertexNeighbors</a> (const size_t _index) const</td></tr>
<tr class="separator:a3de4712a6837b0cb9e72b23be9957eb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89c0c1fda2f7092310d3b5cc77a5d57a"><td class="memItemLeft" align="right" valign="top">std::unordered_set&lt; size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGridOverlay.html#a89c0c1fda2f7092310d3b5cc77a5d57a">LocateAllNeighbors</a> (const size_t _index) const</td></tr>
<tr class="separator:a89c0c1fda2f7092310d3b5cc77a5d57a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Cell Properties</div></td></tr>
<tr class="memitem:a38e78aaeae73d5abb6b85e6ceee4acc7"><td class="memItemLeft" align="right" valign="top"><a id="a38e78aaeae73d5abb6b85e6ceee4acc7" name="a38e78aaeae73d5abb6b85e6ceee4acc7"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>CellLength</b> () const noexcept</td></tr>
<tr class="memdesc:a38e78aaeae73d5abb6b85e6ceee4acc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the length of the grid cells. <br /></td></tr>
<tr class="separator:a38e78aaeae73d5abb6b85e6ceee4acc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0be0d2e86ffa2d02f94f4cad75daeaa3"><td class="memItemLeft" align="right" valign="top">Point3d&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGridOverlay.html#a0be0d2e86ffa2d02f94f4cad75daeaa3">CellCenter</a> (const size_t _index) const noexcept</td></tr>
<tr class="separator:a0be0d2e86ffa2d02f94f4cad75daeaa3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Decomposition Mapping</div></td></tr>
<tr class="memitem:ae49f0c6cb2dc27e7c49908668424fa6d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGridOverlay.html#a73518b6b39a5c8869cf56beec31ad906">DecompositionMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGridOverlay.html#ae49f0c6cb2dc27e7c49908668424fa6d">ComputeDecompositionMap</a> (const <a class="el" href="classWorkspaceDecomposition.html">WorkspaceDecomposition</a> *const _decomposition, const bool _useCollisionDetection=false) const</td></tr>
<tr class="separator:ae49f0c6cb2dc27e7c49908668424fa6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Testing</div></td></tr>
<tr class="memitem:ae8a81507e5dd6d54da3ebfeba14b1a7e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGridOverlay.html#ae8a81507e5dd6d54da3ebfeba14b1a7e">Test</a> (const size_t _trials=0) const</td></tr>
<tr class="separator:ae8a81507e5dd6d54da3ebfeba14b1a7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Local Types</div></td></tr>
<tr class="memitem:afcf6fc05b418b5123c9bc28012505400"><td class="memItemLeft" align="right" valign="top"><a id="afcf6fc05b418b5123c9bc28012505400" name="afcf6fc05b418b5123c9bc28012505400"></a>enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGridOverlay.html#afcf6fc05b418b5123c9bc28012505400">CellSet</a> : unsigned char { <b>Boundary</b> = 1
, <b>Interior</b> = 2
, <b>Closure</b> = 3
 }</td></tr>
<tr class="memdesc:afcf6fc05b418b5123c9bc28012505400"><td class="mdescLeft">&#160;</td><td class="mdescRight">The types of cell sets for use with LocateCells. <br /></td></tr>
<tr class="separator:afcf6fc05b418b5123c9bc28012505400"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73518b6b39a5c8869cf56beec31ad906"><td class="memItemLeft" align="right" valign="top"><a id="a73518b6b39a5c8869cf56beec31ad906" name="a73518b6b39a5c8869cf56beec31ad906"></a>
typedef std::vector&lt; std::vector&lt; const <a class="el" href="classWorkspaceRegion.html">WorkspaceRegion</a> * &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>DecompositionMap</b></td></tr>
<tr class="memdesc:a73518b6b39a5c8869cf56beec31ad906"><td class="mdescLeft">&#160;</td><td class="mdescRight">A mapping from a grid cell index to a set of workspace regions. <br /></td></tr>
<tr class="separator:a73518b6b39a5c8869cf56beec31ad906"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a474ed0ab01122170f0735fcabacefc4f"><td class="memItemLeft" align="right" valign="top"><a id="a474ed0ab01122170f0735fcabacefc4f" name="a474ed0ab01122170f0735fcabacefc4f"></a>
typedef std::array&lt; size_t, 3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>IndexSet</b></td></tr>
<tr class="memdesc:a474ed0ab01122170f0735fcabacefc4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">A set of X, Y, Z indexes for a grid cell. <br /></td></tr>
<tr class="separator:a474ed0ab01122170f0735fcabacefc4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >A 3d grid overlay of a given boundary.</p>
<p >The cells are implicitly represented as either a tuple (x,y,z) or a single 'cell index', which enumerates all cells with a single number. The grid is defined over the minimum and maximum ranges of the boundary, so there may be grid cells partially or completely outside of the boundary (depending its shape and size).</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000048">Todo:</a></b></dt><dd>Generalize to support 2d grids as well as 3d. </dd></dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a51afef65aa767d4229438d8b2ff2a655" name="a51afef65aa767d4229438d8b2ff2a655"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51afef65aa767d4229438d8b2ff2a655">&#9670;&nbsp;</a></span>GridOverlay()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GridOverlay::GridOverlay </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classBoundary.html">Boundary</a> *const&#160;</td>
          <td class="paramname"><em>_b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Construct a grid overlay with cells of a given length. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_b</td><td>The boundary to overlay. </td></tr>
    <tr><td class="paramname">_length</td><td>The cell length to use. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="abdba9adc448be3a77dfa1d3bb33e5366" name="abdba9adc448be3a77dfa1d3bb33e5366"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdba9adc448be3a77dfa1d3bb33e5366">&#9670;&nbsp;</a></span>Size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t GridOverlay::Size </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>_i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Get the number of cells in a given dimension. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_i</td><td>The index for the dimension of interest. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of cells in dimension _i. </dd></dl>

</div>
</div>
<a id="a40e6ec21ca468c2aea5d8c6d04f1fe1d" name="a40e6ec21ca468c2aea5d8c6d04f1fe1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40e6ec21ca468c2aea5d8c6d04f1fe1d">&#9670;&nbsp;</a></span>LocateCell() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t GridOverlay::LocateCell </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCfg.html">Cfg</a> &amp;&#160;</td>
          <td class="paramname"><em>_cfg</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Find the cell that contains the reference point of a configuration. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_cfg</td><td>The configuration to locate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index of the cell which contains _cfg's translational DOFs. </dd></dl>

</div>
</div>
<a id="aa819183185181c09f434f8ed17da6e33" name="aa819183185181c09f434f8ed17da6e33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa819183185181c09f434f8ed17da6e33">&#9670;&nbsp;</a></span>LocateCell() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t GridOverlay::LocateCell </td>
          <td>(</td>
          <td class="paramtype">const Point3d &amp;&#160;</td>
          <td class="paramname"><em>_p</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Find the cell that contains a reference point. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_p</td><td>The point to locate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index of the cell which contains _p. </dd></dl>

</div>
</div>
<a id="a245056ab21132e5b6151b2522fafd126" name="a245056ab21132e5b6151b2522fafd126"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a245056ab21132e5b6151b2522fafd126">&#9670;&nbsp;</a></span>LocateCells() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unordered_set&lt; size_t &gt; GridOverlay::LocateCells </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classBoundary.html">Boundary</a> *const&#160;</td>
          <td class="paramname"><em>_b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGridOverlay.html#afcf6fc05b418b5123c9bc28012505400">CellSet</a>&#160;</td>
          <td class="paramname"><em>_type</em> = <code>CellSet::Closure</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Find the cells that touch a given boundary. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_b</td><td>The boundary of interest. </td></tr>
    <tr><td class="paramname">_type</td><td>The type of cell set to include. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A set of cell indexes that touch _b as described by _type. </dd></dl>

</div>
</div>
<a id="a5b009d33707877f4e4e716819d9f8ffe" name="a5b009d33707877f4e4e716819d9f8ffe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b009d33707877f4e4e716819d9f8ffe">&#9670;&nbsp;</a></span>LocateCells() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unordered_set&lt; size_t &gt; GridOverlay::LocateCells </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGMSPolyhedron.html">GMSPolyhedron</a> &amp;&#160;</td>
          <td class="paramname"><em>_polyhedron</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const mathtool::Transformation &amp;&#160;</td>
          <td class="paramname"><em>_transformation</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGridOverlay.html#afcf6fc05b418b5123c9bc28012505400">CellSet</a>&#160;</td>
          <td class="paramname"><em>_type</em> = <code>CellSet::Closure</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Find the cells that touch a given polyhedron. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_polyhedron</td><td>The polyhedron of interest. </td></tr>
    <tr><td class="paramname">_transformation</td><td>The transformation for _polyhedron. </td></tr>
    <tr><td class="paramname">_type</td><td>The type of cell set to include. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A set of cell indexes that touch _polyhedron as described by _type. </dd></dl>

</div>
</div>
<a id="a1b4fac7a1e567afec6dd680f94259066" name="a1b4fac7a1e567afec6dd680f94259066"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b4fac7a1e567afec6dd680f94259066">&#9670;&nbsp;</a></span>LocateBBXCells() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unordered_set&lt; size_t &gt; GridOverlay::LocateBBXCells </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classBoundary.html">Boundary</a> *const&#160;</td>
          <td class="paramname"><em>_b</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Find the cells that contain a given boundary's bounding box. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_b</td><td>The boundary of interest. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A set of cell indexes that contain _b's bounding box. </dd></dl>

</div>
</div>
<a id="a2715d2da1ea89d584d6d3156a2429461" name="a2715d2da1ea89d584d6d3156a2429461"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2715d2da1ea89d584d6d3156a2429461">&#9670;&nbsp;</a></span>LocateBBXCells() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unordered_set&lt; size_t &gt; GridOverlay::LocateBBXCells </td>
          <td>(</td>
          <td class="paramtype">const Point3d &amp;&#160;</td>
          <td class="paramname"><em>_min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Point3d &amp;&#160;</td>
          <td class="paramname"><em>_max</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Find the cells that contain a bounding box around two points. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_min</td><td>The low-range values. </td></tr>
    <tr><td class="paramname">_max</td><td>The high-range values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A set of cell indexes that contain the bounding box around _min, _max. </dd></dl>

</div>
</div>
<a id="a00b19b87196fbfd7c8bc1640b59a6644" name="a00b19b87196fbfd7c8bc1640b59a6644"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00b19b87196fbfd7c8bc1640b59a6644">&#9670;&nbsp;</a></span>LocateFacetNeighbors()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unordered_set&lt; size_t &gt; GridOverlay::LocateFacetNeighbors </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Locate the neighbors of a cell which share a facet. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_index</td><td>The cell index. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The neighbor cell indexes. </dd></dl>

</div>
</div>
<a id="a4119b768dc1ca2cd9fcb5ff9fecaddee" name="a4119b768dc1ca2cd9fcb5ff9fecaddee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4119b768dc1ca2cd9fcb5ff9fecaddee">&#9670;&nbsp;</a></span>LocateEdgeNeighbors()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unordered_set&lt; size_t &gt; GridOverlay::LocateEdgeNeighbors </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Locate the neighbors of a cell which share an edge but not a facet. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_index</td><td>The cell index. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The neighbor cell indexes. </dd></dl>

</div>
</div>
<a id="a3de4712a6837b0cb9e72b23be9957eb0" name="a3de4712a6837b0cb9e72b23be9957eb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3de4712a6837b0cb9e72b23be9957eb0">&#9670;&nbsp;</a></span>LocateVertexNeighbors()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unordered_set&lt; size_t &gt; GridOverlay::LocateVertexNeighbors </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Locate the neighbors of a cell which share a vertex but not an edge or facet. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_index</td><td>The cell index. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The neighbor cell indexes. </dd></dl>

</div>
</div>
<a id="a89c0c1fda2f7092310d3b5cc77a5d57a" name="a89c0c1fda2f7092310d3b5cc77a5d57a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89c0c1fda2f7092310d3b5cc77a5d57a">&#9670;&nbsp;</a></span>LocateAllNeighbors()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unordered_set&lt; size_t &gt; GridOverlay::LocateAllNeighbors </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Locate all neighbors of a cell. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_index</td><td>The cell index. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The neighbor cell indexes. </dd></dl>

</div>
</div>
<a id="a0be0d2e86ffa2d02f94f4cad75daeaa3" name="a0be0d2e86ffa2d02f94f4cad75daeaa3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0be0d2e86ffa2d02f94f4cad75daeaa3">&#9670;&nbsp;</a></span>CellCenter()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Point3d GridOverlay::CellCenter </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Get the center of a cell. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_index</td><td>The cell index. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The center of cell _index. </dd></dl>

</div>
</div>
<a id="ae49f0c6cb2dc27e7c49908668424fa6d" name="ae49f0c6cb2dc27e7c49908668424fa6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae49f0c6cb2dc27e7c49908668424fa6d">&#9670;&nbsp;</a></span>ComputeDecompositionMap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGridOverlay.html#a73518b6b39a5c8869cf56beec31ad906">GridOverlay::DecompositionMap</a> GridOverlay::ComputeDecompositionMap </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classWorkspaceDecomposition.html">WorkspaceDecomposition</a> *const&#160;</td>
          <td class="paramname"><em>_decomposition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>_useCollisionDetection</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Create a map from grid cell index to the set of decomposition regions which are near to or touch the grid cell. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_decomposition</td><td>The workspace decomposition object to map. </td></tr>
    <tr><td class="paramname">_useCollisionDetection</td><td>Use <a class="el" href="classPQP.html">PQP</a> collision detection to refine the test? </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A mapping m, where m[i] gives a set of _decomposition regions. If not using <a class="el" href="classPQP.html">PQP</a> then the regions are those whos BBX touches grid cell i, otherwise the regions actually touch cell i. </dd></dl>

</div>
</div>
<a id="ae8a81507e5dd6d54da3ebfeba14b1a7e" name="ae8a81507e5dd6d54da3ebfeba14b1a7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8a81507e5dd6d54da3ebfeba14b1a7e">&#9670;&nbsp;</a></span>Test()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GridOverlay::Test </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>_trials</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Test this object. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_trials</td><td>Sample this number of grid cells to test. Or, use zero to test all cells. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">If</td><td>the test fails. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>GridOverlay.h</li>
<li>GridOverlay.cpp</li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.4-->
<!-- start footer part -->
<hr class="footer"/><address class="footer">
<small align="left">PMPL is a project of Texas A&amp;M University</small>
<small align="right">
Generated on Mon Jan 31 2022 14:17:41 for PMPL by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.9.3
</small></address>
</body>
</html>
