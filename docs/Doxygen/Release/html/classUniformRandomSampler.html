<!-- HTML header for doxygen 1.8.4-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.3"/>
<title>PMPL: UniformRandomSampler&lt; MPTraits &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
  <div id="titlearea">
    <table cellspacing="10" cellpadding="10">
      <tr style="height: 56px; text-align: center;">
        <th>PMPL API Reference</th>
        <td>
          <table cellspacing="10" cellpadding="10">
            <tr>
              <td><a class="qindex" href="index.html">Overview</a></td>
              <td><a class="qindex" href="group__Core.html">Core</a></td>
              <td><a class="qindex" href="group__AlgorithmAbstractions.html">Algorithm Abstractions</a></td>
              <td><a class="qindex" href="group__Utilities.html">Utilities</a></td>
              <td><a class="qindex" href="group__ParallelMethods.html">Parallel Methods</a></td>
            </tr>
            <tr>
              <td><a class="qindex" href="modules.html">Modules</a></td>
              <td><a class="qindex" href="inherits.html">Class Hierarchy</a></td>
              <td><a class="qindex" href="annotated.html">Classes</a></td>
              <td><a class="qindex" href="functions.html">Functions</a></td>
            </tr>
            <tr>
              <td><a class="el" href="todo.html" target="_self">Todo List</a></td>
              <td><a class="el" href="bug.html" target="_self">Bug List</a></td>
              <td><a class="qindex" href="group__DeadCode.html">Dead Code</a></td>
            </tr>
          </table>
        </td>
        <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.svg"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
      </tr>
    </table>
  </div>
  <!-- end header part -->
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="classUniformRandomSampler-members.html">List of all members</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a>  </div>
  <div class="headertitle"><div class="title">UniformRandomSampler&lt; MPTraits &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__AlgorithmAbstractions.html">Algorithm Abstractions</a> &raquo; <a class="el" href="group__Samplers.html">Samplers</a></div></div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Construction</div></td></tr>
<tr class="memitem:a181bf14291c8c734892da863f413f040"><td class="memItemLeft" align="right" valign="top"><a id="a181bf14291c8c734892da863f413f040" name="a181bf14291c8c734892da863f413f040"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>UniformRandomSampler</b> ()</td></tr>
<tr class="separator:a181bf14291c8c734892da863f413f040"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ef1c9d24d56b94619b4d7891abf7202"><td class="memItemLeft" align="right" valign="top"><a id="a8ef1c9d24d56b94619b4d7891abf7202" name="a8ef1c9d24d56b94619b4d7891abf7202"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>UniformRandomSampler</b> (<a class="el" href="classXMLNode.html">XMLNode</a> &amp;_node)</td></tr>
<tr class="separator:a8ef1c9d24d56b94619b4d7891abf7202"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91d173075bb8f6684619bbcd4776a61c"><td class="memItemLeft" align="right" valign="top"><a id="a91d173075bb8f6684619bbcd4776a61c" name="a91d173075bb8f6684619bbcd4776a61c"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><b>~UniformRandomSampler</b> ()=default</td></tr>
<tr class="separator:a91d173075bb8f6684619bbcd4776a61c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">MPBaseObject Overrides</div></td></tr>
<tr class="memitem:ac9792d05530f9cd17f308557ff04ffc3"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUniformRandomSampler.html#ac9792d05530f9cd17f308557ff04ffc3">Print</a> (std::ostream &amp;_os) const override</td></tr>
<tr class="separator:ac9792d05530f9cd17f308557ff04ffc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Individual Configuration Sampling</div></td></tr>
<tr class="memitem:af3e00ddf21d407d950d3bd577ef9bf5e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSamplerMethod.html#af3e00ddf21d407d950d3bd577ef9bf5e">Sample</a> (size_t _numNodes, size_t _maxAttempts, const <a class="el" href="classBoundary.html">Boundary</a> *const _boundary, OutputIterator _valid, OutputIterator _invalid)</td></tr>
<tr class="separator:af3e00ddf21d407d950d3bd577ef9bf5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa70a536c4082295c4aeb62f64e6e41e2"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSamplerMethod.html#aa70a536c4082295c4aeb62f64e6e41e2">Sample</a> (size_t _numNodes, size_t _maxAttempts, const <a class="el" href="classBoundary.html">Boundary</a> *const _boundary, OutputIterator _valid)</td></tr>
<tr class="separator:aa70a536c4082295c4aeb62f64e6e41e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd151326aecad9a60f58f7302252fc0b"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSamplerMethod.html#afd151326aecad9a60f58f7302252fc0b">Sample</a> (size_t _numNodes, size_t _maxAttempts, const <a class="el" href="classBoundary.html">Boundary</a> *const _robotBoundary, const <a class="el" href="classBoundary.html">Boundary</a> *const _eeBoundary, OutputIterator _valid, OutputIterator _invalid)</td></tr>
<tr class="separator:afd151326aecad9a60f58f7302252fc0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a910e13fb75a521042b4d81adda1897ba"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSamplerMethod.html#a910e13fb75a521042b4d81adda1897ba">Sample</a> (size_t _numNodes, size_t _maxAttempts, const <a class="el" href="classBoundary.html">Boundary</a> *const _robotBoundary, const <a class="el" href="classBoundary.html">Boundary</a> *const _eeBoundary, OutputIterator _valid)</td></tr>
<tr class="separator:a910e13fb75a521042b4d81adda1897ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad96d5ca883ae4f3926556c356b9e8aea"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSamplerMethod.html#ad96d5ca883ae4f3926556c356b9e8aea">Filter</a> (InputIterator _first, InputIterator _last, size_t _maxAttempts, const <a class="el" href="classBoundary.html">Boundary</a> *const _boundary, OutputIterator _valid, OutputIterator _invalid)</td></tr>
<tr class="separator:ad96d5ca883ae4f3926556c356b9e8aea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe709354d7aba5a4af4abd10dafc16a9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSamplerMethod.html#abe709354d7aba5a4af4abd10dafc16a9">Filter</a> (InputIterator _first, InputIterator _last, size_t _maxAttempts, const <a class="el" href="classBoundary.html">Boundary</a> *const _boundary, OutputIterator _valid)</td></tr>
<tr class="separator:abe709354d7aba5a4af4abd10dafc16a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Group Configuration Sampling</div></td></tr>
<tr class="memitem:a6cee62e80eaee88be4db2eb00fc08af5"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSamplerMethod.html#a6cee62e80eaee88be4db2eb00fc08af5">Sample</a> (size_t _numNodes, size_t _maxAttempts, const <a class="el" href="classBoundary.html">Boundary</a> *const _boundary, GroupOutputIterator _valid, GroupOutputIterator _invalid)</td></tr>
<tr class="separator:a6cee62e80eaee88be4db2eb00fc08af5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af69f938e5fe535511c1f2711e50b197c"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSamplerMethod.html#af69f938e5fe535511c1f2711e50b197c">Sample</a> (size_t _numNodes, size_t _maxAttempts, const <a class="el" href="classBoundary.html">Boundary</a> *const _boundary, GroupOutputIterator _valid)</td></tr>
<tr class="separator:af69f938e5fe535511c1f2711e50b197c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08debb83ce96bf435c410eb1a5fb28df"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSamplerMethod.html#a08debb83ce96bf435c410eb1a5fb28df">Sample</a> (size_t _numNodes, size_t _maxAttempts, const <a class="el" href="classSamplerMethod.html#a4540a2cc61ca8994b9beb6814a9ec4d3">BoundaryMap</a> &amp;_boundary, GroupOutputIterator _valid, GroupOutputIterator _invalid)</td></tr>
<tr class="separator:a08debb83ce96bf435c410eb1a5fb28df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45b69b0c7d464393e0f7f17297a3c9da"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSamplerMethod.html#a45b69b0c7d464393e0f7f17297a3c9da">Sample</a> (size_t _numNodes, size_t _maxAttempts, const <a class="el" href="classSamplerMethod.html#a4540a2cc61ca8994b9beb6814a9ec4d3">BoundaryMap</a> &amp;_boundary, GroupOutputIterator _valid)</td></tr>
<tr class="separator:a45b69b0c7d464393e0f7f17297a3c9da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a871ccd29e379eb45afa651339770fe43"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSamplerMethod.html#a871ccd29e379eb45afa651339770fe43">Filter</a> (GroupInputIterator _first, GroupInputIterator _last, size_t _maxAttempts, const <a class="el" href="classBoundary.html">Boundary</a> *const _boundary, GroupOutputIterator _valid, GroupOutputIterator _invalid)</td></tr>
<tr class="separator:a871ccd29e379eb45afa651339770fe43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7361d04bf4e87dad173f5017f4fdd486"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSamplerMethod.html#a7361d04bf4e87dad173f5017f4fdd486">Filter</a> (GroupInputIterator _first, GroupInputIterator _last, size_t _maxAttempts, const <a class="el" href="classBoundary.html">Boundary</a> *const _boundary, GroupOutputIterator _valid)</td></tr>
<tr class="separator:a7361d04bf4e87dad173f5017f4fdd486"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Initialization</div></td></tr>
<tr class="memitem:a09f350ffaec14a28dd2ced1b86ef9d9e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMPBaseObject.html#a09f350ffaec14a28dd2ced1b86ef9d9e">Initialize</a> ()</td></tr>
<tr class="separator:a09f350ffaec14a28dd2ced1b86ef9d9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Name and Label Accessors</div></td></tr>
<tr class="memitem:aca769e4192d06bd3f4926bf94b9c055a"><td class="memItemLeft" align="right" valign="top"><a id="aca769e4192d06bd3f4926bf94b9c055a" name="aca769e4192d06bd3f4926bf94b9c055a"></a>
const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>GetName</b> () const</td></tr>
<tr class="memdesc:aca769e4192d06bd3f4926bf94b9c055a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the class name for this object. <br /></td></tr>
<tr class="separator:aca769e4192d06bd3f4926bf94b9c055a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad34623e8bcd57c846f8ffe6afe6b427e"><td class="memItemLeft" align="right" valign="top"><a id="ad34623e8bcd57c846f8ffe6afe6b427e" name="ad34623e8bcd57c846f8ffe6afe6b427e"></a>
const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>GetLabel</b> () const</td></tr>
<tr class="memdesc:ad34623e8bcd57c846f8ffe6afe6b427e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the unique label for this object. <br /></td></tr>
<tr class="separator:ad34623e8bcd57c846f8ffe6afe6b427e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57acdb0b1cc5dd45a2a0c08df914bfcf"><td class="memItemLeft" align="right" valign="top"><a id="a57acdb0b1cc5dd45a2a0c08df914bfcf" name="a57acdb0b1cc5dd45a2a0c08df914bfcf"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>GetNameAndLabel</b> () const</td></tr>
<tr class="memdesc:a57acdb0b1cc5dd45a2a0c08df914bfcf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the unique string identifier for this object "m_name::m_label". <br /></td></tr>
<tr class="separator:a57acdb0b1cc5dd45a2a0c08df914bfcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5466caf986b06ca41f1fea274dc47c6"><td class="memItemLeft" align="right" valign="top"><a id="ac5466caf986b06ca41f1fea274dc47c6" name="ac5466caf986b06ca41f1fea274dc47c6"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>SetLabel</b> (const std::string &amp;)</td></tr>
<tr class="memdesc:ac5466caf986b06ca41f1fea274dc47c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the unique label for this object. <br /></td></tr>
<tr class="separator:ac5466caf986b06ca41f1fea274dc47c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">MPLibrary Accessors</div></td></tr>
<tr class="memitem:a697d226daf5f6a2745ef88d2d61a596e"><td class="memItemLeft" align="right" valign="top"><a id="a697d226daf5f6a2745ef88d2d61a596e" name="a697d226daf5f6a2745ef88d2d61a596e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>SetMPLibrary</b> (<a class="el" href="classMPLibraryType.html">MPLibrary</a> *) noexcept</td></tr>
<tr class="memdesc:a697d226daf5f6a2745ef88d2d61a596e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the owning MPLibrary. <br /></td></tr>
<tr class="separator:a697d226daf5f6a2745ef88d2d61a596e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a521b705712b8e7d7197493e411226bda"><td class="memItemLeft" align="right" valign="top"><a id="a521b705712b8e7d7197493e411226bda" name="a521b705712b8e7d7197493e411226bda"></a>
<a class="el" href="classMPLibraryType.html">MPLibrary</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>GetMPLibrary</b> () const noexcept</td></tr>
<tr class="memdesc:a521b705712b8e7d7197493e411226bda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the owning MPLibrary. <br /></td></tr>
<tr class="separator:a521b705712b8e7d7197493e411226bda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfed57adb1cd6e9e6e75062427bc9f7e"><td class="memItemLeft" align="right" valign="top"><a id="abfed57adb1cd6e9e6e75062427bc9f7e" name="abfed57adb1cd6e9e6e75062427bc9f7e"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>IsRunning</b> () const noexcept</td></tr>
<tr class="memdesc:abfed57adb1cd6e9e6e75062427bc9f7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check the library's running flag. <br /></td></tr>
<tr class="separator:abfed57adb1cd6e9e6e75062427bc9f7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a20d7ea8dcfacc2900cc1862c4f8cc8"><td class="memItemLeft" align="right" valign="top"><a id="a8a20d7ea8dcfacc2900cc1862c4f8cc8" name="a8a20d7ea8dcfacc2900cc1862c4f8cc8"></a>
DistanceMetricPointer&#160;</td><td class="memItemRight" valign="bottom"><b>GetDistanceMetric</b> (const std::string &amp;) const noexcept</td></tr>
<tr class="memdesc:a8a20d7ea8dcfacc2900cc1862c4f8cc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a distance metric by label from the owning MPLibrary. <br /></td></tr>
<tr class="separator:a8a20d7ea8dcfacc2900cc1862c4f8cc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2342194564152d2f990223cb62844cbe"><td class="memItemLeft" align="right" valign="top"><a id="a2342194564152d2f990223cb62844cbe" name="a2342194564152d2f990223cb62844cbe"></a>
ValidityCheckerPointer&#160;</td><td class="memItemRight" valign="bottom"><b>GetValidityChecker</b> (const std::string &amp;) const noexcept</td></tr>
<tr class="memdesc:a2342194564152d2f990223cb62844cbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a validity checker by label from the owning MPLibrary. <br /></td></tr>
<tr class="separator:a2342194564152d2f990223cb62844cbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66ba952d43ffc95ff56c889096e9a7d3"><td class="memItemLeft" align="right" valign="top"><a id="a66ba952d43ffc95ff56c889096e9a7d3" name="a66ba952d43ffc95ff56c889096e9a7d3"></a>
NeighborhoodFinderPointer&#160;</td><td class="memItemRight" valign="bottom"><b>GetNeighborhoodFinder</b> (const std::string &amp;) const noexcept</td></tr>
<tr class="memdesc:a66ba952d43ffc95ff56c889096e9a7d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a neighborhood finder by label from the owning MPLibrary. <br /></td></tr>
<tr class="separator:a66ba952d43ffc95ff56c889096e9a7d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a2dff0888a2ea84bb38a556654a4701"><td class="memItemLeft" align="right" valign="top"><a id="a9a2dff0888a2ea84bb38a556654a4701" name="a9a2dff0888a2ea84bb38a556654a4701"></a>
SamplerPointer&#160;</td><td class="memItemRight" valign="bottom"><b>GetSampler</b> (const std::string &amp;) const noexcept</td></tr>
<tr class="memdesc:a9a2dff0888a2ea84bb38a556654a4701"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a sampler by label from the owning MPLibrary. <br /></td></tr>
<tr class="separator:a9a2dff0888a2ea84bb38a556654a4701"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23231ec80cf4dc6103fcbe6967611de8"><td class="memItemLeft" align="right" valign="top"><a id="a23231ec80cf4dc6103fcbe6967611de8" name="a23231ec80cf4dc6103fcbe6967611de8"></a>
LocalPlannerPointer&#160;</td><td class="memItemRight" valign="bottom"><b>GetLocalPlanner</b> (const std::string &amp;) const noexcept</td></tr>
<tr class="memdesc:a23231ec80cf4dc6103fcbe6967611de8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a local planner by label from the owning MPLibrary. <br /></td></tr>
<tr class="separator:a23231ec80cf4dc6103fcbe6967611de8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1c21a5eb19462d7fbc1d9d7ad44a337"><td class="memItemLeft" align="right" valign="top"><a id="ae1c21a5eb19462d7fbc1d9d7ad44a337" name="ae1c21a5eb19462d7fbc1d9d7ad44a337"></a>
ExtenderPointer&#160;</td><td class="memItemRight" valign="bottom"><b>GetExtender</b> (const std::string &amp;) const noexcept</td></tr>
<tr class="memdesc:ae1c21a5eb19462d7fbc1d9d7ad44a337"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an extender by label from the owning MPLibrary. <br /></td></tr>
<tr class="separator:ae1c21a5eb19462d7fbc1d9d7ad44a337"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ba42a3ccbbe218c0ad5212b320647e2"><td class="memItemLeft" align="right" valign="top"><a id="a2ba42a3ccbbe218c0ad5212b320647e2" name="a2ba42a3ccbbe218c0ad5212b320647e2"></a>
PathModifierPointer&#160;</td><td class="memItemRight" valign="bottom"><b>GetPathModifier</b> (const std::string &amp;) const noexcept</td></tr>
<tr class="memdesc:a2ba42a3ccbbe218c0ad5212b320647e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a path modifier by label from the owning MPLibrary. <br /></td></tr>
<tr class="separator:a2ba42a3ccbbe218c0ad5212b320647e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03a0372144b35900bd3783787d8ece23"><td class="memItemLeft" align="right" valign="top"><a id="a03a0372144b35900bd3783787d8ece23" name="a03a0372144b35900bd3783787d8ece23"></a>
ConnectorPointer&#160;</td><td class="memItemRight" valign="bottom"><b>GetConnector</b> (const std::string &amp;) const noexcept</td></tr>
<tr class="memdesc:a03a0372144b35900bd3783787d8ece23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a connector by label from the owning MPLibrary. <br /></td></tr>
<tr class="separator:a03a0372144b35900bd3783787d8ece23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ae69fab32bc22d9a40183c2ddcad070"><td class="memItemLeft" align="right" valign="top"><a id="a6ae69fab32bc22d9a40183c2ddcad070" name="a6ae69fab32bc22d9a40183c2ddcad070"></a>
MetricPointer&#160;</td><td class="memItemRight" valign="bottom"><b>GetMetric</b> (const std::string &amp;) const noexcept</td></tr>
<tr class="memdesc:a6ae69fab32bc22d9a40183c2ddcad070"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a metric by label from the owning MPLibrary. <br /></td></tr>
<tr class="separator:a6ae69fab32bc22d9a40183c2ddcad070"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af952ecbef2818c807056dd1ee562dfa2"><td class="memItemLeft" align="right" valign="top"><a id="af952ecbef2818c807056dd1ee562dfa2" name="af952ecbef2818c807056dd1ee562dfa2"></a>
MapEvaluatorPointer&#160;</td><td class="memItemRight" valign="bottom"><b>GetMapEvaluator</b> (const std::string &amp;) const noexcept</td></tr>
<tr class="memdesc:af952ecbef2818c807056dd1ee562dfa2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a map evaluator by label from the owning MPLibrary. <br /></td></tr>
<tr class="separator:af952ecbef2818c807056dd1ee562dfa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5db3fdc249613226e1bfb9748d7e419"><td class="memItemLeft" align="right" valign="top"><a id="ab5db3fdc249613226e1bfb9748d7e419" name="ab5db3fdc249613226e1bfb9748d7e419"></a>
MPStrategyPointer&#160;</td><td class="memItemRight" valign="bottom"><b>GetMPStrategy</b> (const std::string &amp;) const noexcept</td></tr>
<tr class="memdesc:ab5db3fdc249613226e1bfb9748d7e419"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a strategy by label from the owning MPLibrary. <br /></td></tr>
<tr class="separator:ab5db3fdc249613226e1bfb9748d7e419"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cec62eec53411129380a74d357189c7"><td class="memItemLeft" align="right" valign="top"><a id="a3cec62eec53411129380a74d357189c7" name="a3cec62eec53411129380a74d357189c7"></a>
<a class="el" href="classMPToolsType.html">MPTraits::MPTools</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>GetMPTools</b> () const noexcept</td></tr>
<tr class="memdesc:a3cec62eec53411129380a74d357189c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the MPTools container from the owning MPLibrary. <br /></td></tr>
<tr class="separator:a3cec62eec53411129380a74d357189c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Problem Accessors</div></td></tr>
<tr class="memitem:a2a18befe086f47ce26c93f08c4364397"><td class="memItemLeft" align="right" valign="top"><a id="a2a18befe086f47ce26c93f08c4364397" name="a2a18befe086f47ce26c93f08c4364397"></a>
<a class="el" href="classMPProblem.html">MPProblem</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>GetMPProblem</b> () const noexcept</td></tr>
<tr class="memdesc:a2a18befe086f47ce26c93f08c4364397"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the library's current <a class="el" href="classMPProblem.html">MPProblem</a>. <br /></td></tr>
<tr class="separator:a2a18befe086f47ce26c93f08c4364397"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84dfed53d5b39787d1a9fa44f9a833e1"><td class="memItemLeft" align="right" valign="top"><a id="a84dfed53d5b39787d1a9fa44f9a833e1" name="a84dfed53d5b39787d1a9fa44f9a833e1"></a>
<a class="el" href="classEnvironment.html">Environment</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>GetEnvironment</b> () const noexcept</td></tr>
<tr class="memdesc:a84dfed53d5b39787d1a9fa44f9a833e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current environment. <br /></td></tr>
<tr class="separator:a84dfed53d5b39787d1a9fa44f9a833e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa73f5579b26a2391c5ef414cc3132602"><td class="memItemLeft" align="right" valign="top"><a id="aa73f5579b26a2391c5ef414cc3132602" name="aa73f5579b26a2391c5ef414cc3132602"></a>
<a class="el" href="classMPTask.html">MPTask</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>GetTask</b> () const noexcept</td></tr>
<tr class="memdesc:aa73f5579b26a2391c5ef414cc3132602"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current task. <br /></td></tr>
<tr class="separator:aa73f5579b26a2391c5ef414cc3132602"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3eee19a7be268bff7c7497be8d0239a7"><td class="memItemLeft" align="right" valign="top"><a id="a3eee19a7be268bff7c7497be8d0239a7" name="a3eee19a7be268bff7c7497be8d0239a7"></a>
<a class="el" href="classGroupTask.html">GroupTask</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>GetGroupTask</b> () const noexcept</td></tr>
<tr class="memdesc:a3eee19a7be268bff7c7497be8d0239a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current group task. <br /></td></tr>
<tr class="separator:a3eee19a7be268bff7c7497be8d0239a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Solution Accessors</div></td></tr>
<tr class="memitem:a5c683b92e92fdc2c410b73ddecaf0ca5"><td class="memItemLeft" align="right" valign="top"><a id="a5c683b92e92fdc2c410b73ddecaf0ca5" name="a5c683b92e92fdc2c410b73ddecaf0ca5"></a>
<a class="el" href="classMPSolutionType.html">MPSolution</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>GetMPSolution</b> () const noexcept</td></tr>
<tr class="separator:a5c683b92e92fdc2c410b73ddecaf0ca5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab12b31f78fe0ead35bd1696477d6252b"><td class="memItemLeft" align="right" valign="top"><a id="ab12b31f78fe0ead35bd1696477d6252b" name="ab12b31f78fe0ead35bd1696477d6252b"></a>
<a class="el" href="classRoadmapGraph.html">RoadmapType</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>GetRoadmap</b> (<a class="el" href="classRobot.html">Robot</a> *const _r=nullptr) const noexcept</td></tr>
<tr class="memdesc:ab12b31f78fe0ead35bd1696477d6252b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current free-space roadmap. <br /></td></tr>
<tr class="separator:ab12b31f78fe0ead35bd1696477d6252b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a2e6b0792de5ad4fea367b800c9104c"><td class="memItemLeft" align="right" valign="top"><a id="a4a2e6b0792de5ad4fea367b800c9104c" name="a4a2e6b0792de5ad4fea367b800c9104c"></a>
<a class="el" href="classGroupRoadmap.html">GroupRoadmapType</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>GetGroupRoadmap</b> (<a class="el" href="classRobotGroup.html">RobotGroup</a> *const _g=nullptr) const noexcept</td></tr>
<tr class="memdesc:a4a2e6b0792de5ad4fea367b800c9104c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current free-space group roadmap. <br /></td></tr>
<tr class="separator:a4a2e6b0792de5ad4fea367b800c9104c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3b66c53b09bfd09ea85985e9594d612"><td class="memItemLeft" align="right" valign="top"><a id="aa3b66c53b09bfd09ea85985e9594d612" name="aa3b66c53b09bfd09ea85985e9594d612"></a>
<a class="el" href="classRoadmapGraph.html">RoadmapType</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>GetBlockRoadmap</b> (<a class="el" href="classRobot.html">Robot</a> *const _r=nullptr) const noexcept</td></tr>
<tr class="memdesc:aa3b66c53b09bfd09ea85985e9594d612"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current obstacle-space roadmap. <br /></td></tr>
<tr class="separator:aa3b66c53b09bfd09ea85985e9594d612"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5eed9cee8bec2a10ccb807252dd48b48"><td class="memItemLeft" align="right" valign="top"><a id="a5eed9cee8bec2a10ccb807252dd48b48" name="a5eed9cee8bec2a10ccb807252dd48b48"></a>
<a class="el" href="classPathType.html">Path</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>GetPath</b> (<a class="el" href="classRobot.html">Robot</a> *const _r=nullptr) const noexcept</td></tr>
<tr class="memdesc:a5eed9cee8bec2a10ccb807252dd48b48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current best path. <br /></td></tr>
<tr class="separator:a5eed9cee8bec2a10ccb807252dd48b48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5876ac36ce7e8c97564a464ee25ca45e"><td class="memItemLeft" align="right" valign="top"><a id="a5876ac36ce7e8c97564a464ee25ca45e" name="a5876ac36ce7e8c97564a464ee25ca45e"></a>
<a class="el" href="classGroupPath.html">GroupPath</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>GetGroupPath</b> (<a class="el" href="classRobotGroup.html">RobotGroup</a> *const _g=nullptr) const noexcept</td></tr>
<tr class="memdesc:a5876ac36ce7e8c97564a464ee25ca45e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current best group path. <br /></td></tr>
<tr class="separator:a5876ac36ce7e8c97564a464ee25ca45e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a375e4d95326ba7b0d9751aafd0e5e38f"><td class="memItemLeft" align="right" valign="top"><a id="a375e4d95326ba7b0d9751aafd0e5e38f" name="a375e4d95326ba7b0d9751aafd0e5e38f"></a>
<a class="el" href="classStatClass.html">StatClass</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>GetStatClass</b> () const noexcept</td></tr>
<tr class="memdesc:a375e4d95326ba7b0d9751aafd0e5e38f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current <a class="el" href="classStatClass.html">StatClass</a>. <br /></td></tr>
<tr class="separator:a375e4d95326ba7b0d9751aafd0e5e38f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62a7924385a0268299e26f77e0a10f3d"><td class="memItemLeft" align="right" valign="top"><a id="a62a7924385a0268299e26f77e0a10f3d" name="a62a7924385a0268299e26f77e0a10f3d"></a>
<a class="el" href="classLocalObstacleMapType.html">LocalObstacleMap</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>GetLocalObstacleMap</b> () const noexcept</td></tr>
<tr class="memdesc:a62a7924385a0268299e26f77e0a10f3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the local obstacle map. <br /></td></tr>
<tr class="separator:a62a7924385a0268299e26f77e0a10f3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb4f647ec2b50698e0c4bb676f1d103e"><td class="memItemLeft" align="right" valign="top"><a id="acb4f647ec2b50698e0c4bb676f1d103e" name="acb4f647ec2b50698e0c4bb676f1d103e"></a>
<a class="el" href="classGoalTrackerType.html">GoalTracker</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>GetGoalTracker</b> () const noexcept</td></tr>
<tr class="memdesc:acb4f647ec2b50698e0c4bb676f1d103e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the goal tracker. <br /></td></tr>
<tr class="separator:acb4f647ec2b50698e0c4bb676f1d103e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Motion Planning Types</div></td></tr>
<tr class="memitem:a1b277831501bdf46a0145cfbd0e1f81c"><td class="memItemLeft" align="right" valign="top"><a id="a1b277831501bdf46a0145cfbd0e1f81c" name="a1b277831501bdf46a0145cfbd0e1f81c"></a>
typedef MPTraits::CfgType&#160;</td><td class="memItemRight" valign="bottom"><b>CfgType</b></td></tr>
<tr class="separator:a1b277831501bdf46a0145cfbd0e1f81c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26ca5b2dcd6b3dba9f056344165eeefe"><td class="memItemLeft" align="right" valign="top"><a id="a26ca5b2dcd6b3dba9f056344165eeefe" name="a26ca5b2dcd6b3dba9f056344165eeefe"></a>
typedef <a class="el" href="classGroupCfg.html">MPTraits::GroupCfgType</a>&#160;</td><td class="memItemRight" valign="bottom"><b>GroupCfgType</b></td></tr>
<tr class="separator:a26ca5b2dcd6b3dba9f056344165eeefe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Local Types</div></td></tr>
<tr class="memitem:ab80209ec071b82f6481e4499bbc5a809"><td class="memItemLeft" align="right" valign="top"><a id="ab80209ec071b82f6481e4499bbc5a809" name="ab80209ec071b82f6481e4499bbc5a809"></a>
typedef std::vector&lt; CfgType &gt;::iterator&#160;</td><td class="memItemRight" valign="bottom"><b>InputIterator</b></td></tr>
<tr class="separator:ab80209ec071b82f6481e4499bbc5a809"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6807e745714d459c1614dae289f9b52a"><td class="memItemLeft" align="right" valign="top"><a id="a6807e745714d459c1614dae289f9b52a" name="a6807e745714d459c1614dae289f9b52a"></a>
typedef std::back_insert_iterator&lt; std::vector&lt; CfgType &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>OutputIterator</b></td></tr>
<tr class="separator:a6807e745714d459c1614dae289f9b52a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf81379597982ad148e944f6328446f1"><td class="memItemLeft" align="right" valign="top"><a id="acf81379597982ad148e944f6328446f1" name="acf81379597982ad148e944f6328446f1"></a>
typedef std::vector&lt; <a class="el" href="classGroupCfg.html">GroupCfgType</a> &gt;::iterator&#160;</td><td class="memItemRight" valign="bottom"><b>GroupInputIterator</b></td></tr>
<tr class="separator:acf81379597982ad148e944f6328446f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafbce92d8b2a139923d48f3decfd6e20"><td class="memItemLeft" align="right" valign="top"><a id="aafbce92d8b2a139923d48f3decfd6e20" name="aafbce92d8b2a139923d48f3decfd6e20"></a>
typedef std::back_insert_iterator&lt; std::vector&lt; <a class="el" href="classGroupCfg.html">GroupCfgType</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>GroupOutputIterator</b></td></tr>
<tr class="separator:aafbce92d8b2a139923d48f3decfd6e20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4540a2cc61ca8994b9beb6814a9ec4d3"><td class="memItemLeft" align="right" valign="top"><a id="a4540a2cc61ca8994b9beb6814a9ec4d3" name="a4540a2cc61ca8994b9beb6814a9ec4d3"></a>
typedef std::map&lt; <a class="el" href="classRobot.html">Robot</a> *, const <a class="el" href="classBoundary.html">Boundary</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>BoundaryMap</b></td></tr>
<tr class="memdesc:a4540a2cc61ca8994b9beb6814a9ec4d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">A map from robots to sampling boundaries. <br /></td></tr>
<tr class="separator:a4540a2cc61ca8994b9beb6814a9ec4d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Local Types</div></td></tr>
<tr class="memitem:afdfe49d535de506c369d53c3f35c4861"><td class="memItemLeft" align="right" valign="top"><a id="afdfe49d535de506c369d53c3f35c4861" name="afdfe49d535de506c369d53c3f35c4861"></a>
typedef <a class="el" href="classRoadmapGraph.html">MPTraits::RoadmapType</a>&#160;</td><td class="memItemRight" valign="bottom"><b>RoadmapType</b></td></tr>
<tr class="separator:afdfe49d535de506c369d53c3f35c4861"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad06ed006429808c548ad2c88d7362652"><td class="memItemLeft" align="right" valign="top"><a id="ad06ed006429808c548ad2c88d7362652" name="ad06ed006429808c548ad2c88d7362652"></a>
typedef <a class="el" href="classGroupRoadmap.html">MPTraits::GroupRoadmapType</a>&#160;</td><td class="memItemRight" valign="bottom"><b>GroupRoadmapType</b></td></tr>
<tr class="separator:ad06ed006429808c548ad2c88d7362652"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e5ed51342d87f6e4ca22300478d1754"><td class="memItemLeft" align="right" valign="top"><a id="a1e5ed51342d87f6e4ca22300478d1754" name="a1e5ed51342d87f6e4ca22300478d1754"></a>
typedef <a class="el" href="classLocalObstacleMapType.html">MPTraits::LocalObstacleMap</a>&#160;</td><td class="memItemRight" valign="bottom"><b>LocalObstacleMap</b></td></tr>
<tr class="separator:a1e5ed51342d87f6e4ca22300478d1754"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea9c3bca368d8ed3aaf2687b159ca561"><td class="memItemLeft" align="right" valign="top"><a id="aea9c3bca368d8ed3aaf2687b159ca561" name="aea9c3bca368d8ed3aaf2687b159ca561"></a>
typedef <a class="el" href="classPathType.html">MPTraits::Path</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Path</b></td></tr>
<tr class="separator:aea9c3bca368d8ed3aaf2687b159ca561"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a171d332ff9e7d24af57efce2db4d7c60"><td class="memItemLeft" align="right" valign="top"><a id="a171d332ff9e7d24af57efce2db4d7c60" name="a171d332ff9e7d24af57efce2db4d7c60"></a>
typedef <a class="el" href="classGroupPath.html">MPTraits::GroupPathType</a>&#160;</td><td class="memItemRight" valign="bottom"><b>GroupPath</b></td></tr>
<tr class="separator:a171d332ff9e7d24af57efce2db4d7c60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15b148d41701475b3b94c4a163157f89"><td class="memItemLeft" align="right" valign="top"><a id="a15b148d41701475b3b94c4a163157f89" name="a15b148d41701475b3b94c4a163157f89"></a>
typedef <a class="el" href="classMPLibraryType.html">MPTraits::MPLibrary</a>&#160;</td><td class="memItemRight" valign="bottom"><b>MPLibrary</b></td></tr>
<tr class="separator:a15b148d41701475b3b94c4a163157f89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6aa70c68a7aa522d074423ca469a4611"><td class="memItemLeft" align="right" valign="top"><a id="a6aa70c68a7aa522d074423ca469a4611" name="a6aa70c68a7aa522d074423ca469a4611"></a>
typedef <a class="el" href="classMPSolutionType.html">MPTraits::MPSolution</a>&#160;</td><td class="memItemRight" valign="bottom"><b>MPSolution</b></td></tr>
<tr class="separator:a6aa70c68a7aa522d074423ca469a4611"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59a6f8a70e1e9d3bc80ed1709f37adb9"><td class="memItemLeft" align="right" valign="top"><a id="a59a6f8a70e1e9d3bc80ed1709f37adb9" name="a59a6f8a70e1e9d3bc80ed1709f37adb9"></a>
typedef <a class="el" href="classGoalTrackerType.html">MPTraits::GoalTracker</a>&#160;</td><td class="memItemRight" valign="bottom"><b>GoalTracker</b></td></tr>
<tr class="separator:a59a6f8a70e1e9d3bc80ed1709f37adb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf3cea401f0b3ade1d909fc527246a08"><td class="memItemLeft" align="right" valign="top"><a id="aaf3cea401f0b3ade1d909fc527246a08" name="aaf3cea401f0b3ade1d909fc527246a08"></a>
typedef MPLibrary::SamplerPointer&#160;</td><td class="memItemRight" valign="bottom"><b>SamplerPointer</b></td></tr>
<tr class="separator:aaf3cea401f0b3ade1d909fc527246a08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae65bc5a79747909242133bf6d00c993d"><td class="memItemLeft" align="right" valign="top"><a id="ae65bc5a79747909242133bf6d00c993d" name="ae65bc5a79747909242133bf6d00c993d"></a>
typedef MPLibrary::LocalPlannerPointer&#160;</td><td class="memItemRight" valign="bottom"><b>LocalPlannerPointer</b></td></tr>
<tr class="separator:ae65bc5a79747909242133bf6d00c993d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5eb6e9a2ee24cc60b2280c8d7a86dcf4"><td class="memItemLeft" align="right" valign="top"><a id="a5eb6e9a2ee24cc60b2280c8d7a86dcf4" name="a5eb6e9a2ee24cc60b2280c8d7a86dcf4"></a>
typedef MPLibrary::ExtenderPointer&#160;</td><td class="memItemRight" valign="bottom"><b>ExtenderPointer</b></td></tr>
<tr class="separator:a5eb6e9a2ee24cc60b2280c8d7a86dcf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d8006e11da7b3e4d5ac8eee9c6af86a"><td class="memItemLeft" align="right" valign="top"><a id="a9d8006e11da7b3e4d5ac8eee9c6af86a" name="a9d8006e11da7b3e4d5ac8eee9c6af86a"></a>
typedef MPLibrary::PathModifierPointer&#160;</td><td class="memItemRight" valign="bottom"><b>PathModifierPointer</b></td></tr>
<tr class="separator:a9d8006e11da7b3e4d5ac8eee9c6af86a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97ef39036c999f2b85697d651a3709b6"><td class="memItemLeft" align="right" valign="top"><a id="a97ef39036c999f2b85697d651a3709b6" name="a97ef39036c999f2b85697d651a3709b6"></a>
typedef MPLibrary::ConnectorPointer&#160;</td><td class="memItemRight" valign="bottom"><b>ConnectorPointer</b></td></tr>
<tr class="separator:a97ef39036c999f2b85697d651a3709b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1033e6b77f138cd5b0c963b85c2102c8"><td class="memItemLeft" align="right" valign="top"><a id="a1033e6b77f138cd5b0c963b85c2102c8" name="a1033e6b77f138cd5b0c963b85c2102c8"></a>
typedef MPLibrary::MetricPointer&#160;</td><td class="memItemRight" valign="bottom"><b>MetricPointer</b></td></tr>
<tr class="separator:a1033e6b77f138cd5b0c963b85c2102c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab26d90683e004e04060c66490f1abef9"><td class="memItemLeft" align="right" valign="top"><a id="ab26d90683e004e04060c66490f1abef9" name="ab26d90683e004e04060c66490f1abef9"></a>
typedef MPLibrary::MapEvaluatorPointer&#160;</td><td class="memItemRight" valign="bottom"><b>MapEvaluatorPointer</b></td></tr>
<tr class="separator:ab26d90683e004e04060c66490f1abef9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c55c91725735d71ee1b6e07d0da9427"><td class="memItemLeft" align="right" valign="top"><a id="a6c55c91725735d71ee1b6e07d0da9427" name="a6c55c91725735d71ee1b6e07d0da9427"></a>
typedef MPLibrary::MPStrategyPointer&#160;</td><td class="memItemRight" valign="bottom"><b>MPStrategyPointer</b></td></tr>
<tr class="separator:a6c55c91725735d71ee1b6e07d0da9427"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae603ce0344d2bf534dd9623be0625f90"><td class="memItemLeft" align="right" valign="top"><a id="ae603ce0344d2bf534dd9623be0625f90" name="ae603ce0344d2bf534dd9623be0625f90"></a>
typedef MPLibrary::DistanceMetricPointer&#160;</td><td class="memItemRight" valign="bottom"><b>DistanceMetricPointer</b></td></tr>
<tr class="separator:ae603ce0344d2bf534dd9623be0625f90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96b8dadf9f28e3513e2bd059dfc0344a"><td class="memItemLeft" align="right" valign="top"><a id="a96b8dadf9f28e3513e2bd059dfc0344a" name="a96b8dadf9f28e3513e2bd059dfc0344a"></a>
typedef MPLibrary::ValidityCheckerPointer&#160;</td><td class="memItemRight" valign="bottom"><b>ValidityCheckerPointer</b></td></tr>
<tr class="separator:a96b8dadf9f28e3513e2bd059dfc0344a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a931bd7b8fd743b7f7313046659866113"><td class="memItemLeft" align="right" valign="top"><a id="a931bd7b8fd743b7f7313046659866113" name="a931bd7b8fd743b7f7313046659866113"></a>
typedef MPLibrary::NeighborhoodFinderPointer&#160;</td><td class="memItemRight" valign="bottom"><b>NeighborhoodFinderPointer</b></td></tr>
<tr class="separator:a931bd7b8fd743b7f7313046659866113"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:ab59d82cd734f77fdc17eddb8517461da"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMPBaseObject.html#ab59d82cd734f77fdc17eddb8517461da">SetName</a> (const std::string &amp;_s)</td></tr>
<tr class="separator:ab59d82cd734f77fdc17eddb8517461da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac25ef62edadc2b762f849aa66e2ab66b"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMPBaseObject.html#ac25ef62edadc2b762f849aa66e2ab66b">GetBaseFilename</a> () const</td></tr>
<tr class="separator:ac25ef62edadc2b762f849aa66e2ab66b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Sampler Rule</div></td></tr>
<tr class="memitem:ac7dbf155faf382103921ced72be12761"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUniformRandomSampler.html#ac7dbf155faf382103921ced72be12761">Sampler</a> (CfgType &amp;_cfg, const <a class="el" href="classBoundary.html">Boundary</a> *const _boundary, std::vector&lt; CfgType &gt; &amp;_valid, std::vector&lt; CfgType &gt; &amp;_invalid) override</td></tr>
<tr class="separator:ac7dbf155faf382103921ced72be12761"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7160d7ec668775c7b388168d7899a7be"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUniformRandomSampler.html#a7160d7ec668775c7b388168d7899a7be">Sampler</a> (<a class="el" href="classGroupCfg.html">GroupCfgType</a> &amp;_cfg, const <a class="el" href="classBoundary.html">Boundary</a> *const _boundary, std::vector&lt; <a class="el" href="classGroupCfg.html">GroupCfgType</a> &gt; &amp;_valid, std::vector&lt; <a class="el" href="classGroupCfg.html">GroupCfgType</a> &gt; &amp;_invalid) override</td></tr>
<tr class="separator:a7160d7ec668775c7b388168d7899a7be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09e75aead3303ff1c1ac31e89eb1baf1"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUniformRandomSampler.html#a09e75aead3303ff1c1ac31e89eb1baf1">Sampler</a> (<a class="el" href="classGroupCfg.html">GroupCfgType</a> &amp;_cfg, const <a class="el" href="classSamplerMethod.html#a4540a2cc61ca8994b9beb6814a9ec4d3">BoundaryMap</a> &amp;_boundaryMap, std::vector&lt; <a class="el" href="classGroupCfg.html">GroupCfgType</a> &gt; &amp;_valid, std::vector&lt; <a class="el" href="classGroupCfg.html">GroupCfgType</a> &gt; &amp;_invalid) override</td></tr>
<tr class="separator:a09e75aead3303ff1c1ac31e89eb1baf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Sampler Rule</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p >The default implementations of these throw exceptions so that derived classes can avoid implementing unsupported functions (as opposed to making these pure virtual). </p>
</div></td></tr>
<tr class="memitem:a513d553fce6ead8a4d96bea7a781c82e"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSamplerMethod.html#a513d553fce6ead8a4d96bea7a781c82e">Sampler</a> (CfgType &amp;_cfg, const <a class="el" href="classBoundary.html">Boundary</a> *const _robotBoundary, const <a class="el" href="classBoundary.html">Boundary</a> *const _eeBoundary, std::vector&lt; CfgType &gt; &amp;_valid, std::vector&lt; CfgType &gt; &amp;_invalid)</td></tr>
<tr class="separator:a513d553fce6ead8a4d96bea7a781c82e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-attribs" name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a4dce0c7792a2e35db03e46fbdc0038d3"><td class="memItemLeft" align="right" valign="top"><a id="a4dce0c7792a2e35db03e46fbdc0038d3" name="a4dce0c7792a2e35db03e46fbdc0038d3"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>m_debug</b></td></tr>
<tr class="memdesc:a4dce0c7792a2e35db03e46fbdc0038d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print debug info? <br /></td></tr>
<tr class="separator:a4dce0c7792a2e35db03e46fbdc0038d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;class <a class="el" href="classMPTraits.html">MPTraits</a>&gt;<br />
class UniformRandomSampler&lt; MPTraits &gt;</div><p >This sampler only validity-checks the input sample. It is only a 'uniform random' sampler if given a uniform random distribution of input samples. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="ac9792d05530f9cd17f308557ff04ffc3" name="ac9792d05530f9cd17f308557ff04ffc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9792d05530f9cd17f308557ff04ffc3">&#9670;&nbsp;</a></span>Print()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classMPTraits.html">MPTraits</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classUniformRandomSampler.html">UniformRandomSampler</a>&lt; <a class="el" href="classMPTraits.html">MPTraits</a> &gt;::Print </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>_os</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Print internal state of this object. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_os</td><td>The std::ostream to print to. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classMPBaseObject.html#a4d111a2d7d53d243cdd4cd89ffa65212">MPBaseObject&lt; MPTraits &gt;</a>.</p>

</div>
</div>
<a id="ac7dbf155faf382103921ced72be12761" name="ac7dbf155faf382103921ced72be12761"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7dbf155faf382103921ced72be12761">&#9670;&nbsp;</a></span>Sampler() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classMPTraits.html">MPTraits</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classUniformRandomSampler.html">UniformRandomSampler</a>&lt; <a class="el" href="classMPTraits.html">MPTraits</a> &gt;::Sampler </td>
          <td>(</td>
          <td class="paramtype">CfgType &amp;&#160;</td>
          <td class="paramname"><em>_cfg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classBoundary.html">Boundary</a> *const&#160;</td>
          <td class="paramname"><em>_boundary</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; CfgType &gt; &amp;&#160;</td>
          <td class="paramname"><em>_valid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; CfgType &gt; &amp;&#160;</td>
          <td class="paramname"><em>_invalid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Takes a single input configuration and applies the sampler rule to generate one or more output configurations. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_cfg</td><td>The input configuration. </td></tr>
    <tr><td class="paramname">_boundary</td><td>The sampling boundary. </td></tr>
    <tr><td class="paramname">_valid</td><td>The resulting output configurations. </td></tr>
    <tr><td class="paramname">_invalid</td><td>The (optional) return for failed attempts. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if a valid configuration was generated, false otherwise. </dd></dl>

<p>Reimplemented from <a class="el" href="classSamplerMethod.html#a236055d29dc7a704200e39df16bb5a77">SamplerMethod&lt; MPTraits &gt;</a>.</p>

</div>
</div>
<a id="a7160d7ec668775c7b388168d7899a7be" name="a7160d7ec668775c7b388168d7899a7be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7160d7ec668775c7b388168d7899a7be">&#9670;&nbsp;</a></span>Sampler() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classMPTraits.html">MPTraits</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classUniformRandomSampler.html">UniformRandomSampler</a>&lt; <a class="el" href="classMPTraits.html">MPTraits</a> &gt;::Sampler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classGroupCfg.html">GroupCfgType</a> &amp;&#160;</td>
          <td class="paramname"><em>_cfg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classBoundary.html">Boundary</a> *const&#160;</td>
          <td class="paramname"><em>_boundary</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classGroupCfg.html">GroupCfgType</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>_valid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classGroupCfg.html">GroupCfgType</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>_invalid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Takes a single input configuration and applies the sampler rule to generate one or more output configurations. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_cfg</td><td>The input group configuration. </td></tr>
    <tr><td class="paramname">_boundary</td><td>The sampling boundary. </td></tr>
    <tr><td class="paramname">_valid</td><td>The resulting output configurations. </td></tr>
    <tr><td class="paramname">_invalid</td><td>The (optional) return for failed attempts. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if a valid configuration was generated, false otherwise. </dd></dl>

<p>Reimplemented from <a class="el" href="classSamplerMethod.html#ace2bf75640e93b9987e6a9aa6de697fc">SamplerMethod&lt; MPTraits &gt;</a>.</p>

</div>
</div>
<a id="a09e75aead3303ff1c1ac31e89eb1baf1" name="a09e75aead3303ff1c1ac31e89eb1baf1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09e75aead3303ff1c1ac31e89eb1baf1">&#9670;&nbsp;</a></span>Sampler() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classMPTraits.html">MPTraits</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classUniformRandomSampler.html">UniformRandomSampler</a>&lt; <a class="el" href="classMPTraits.html">MPTraits</a> &gt;::Sampler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classGroupCfg.html">GroupCfgType</a> &amp;&#160;</td>
          <td class="paramname"><em>_cfg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSamplerMethod.html#a4540a2cc61ca8994b9beb6814a9ec4d3">BoundaryMap</a> &amp;&#160;</td>
          <td class="paramname"><em>_boundaryMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classGroupCfg.html">GroupCfgType</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>_valid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classGroupCfg.html">GroupCfgType</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>_invalid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >This version specifies a (possibly different) boundary for each robot. Robots which are not in the boundary map will use the environment boundary. This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

<p>Reimplemented from <a class="el" href="classSamplerMethod.html#a724653eb28d90eb3b2198605bf3b27c6">SamplerMethod&lt; MPTraits &gt;</a>.</p>

</div>
</div>
<a id="af3e00ddf21d407d950d3bd577ef9bf5e" name="af3e00ddf21d407d950d3bd577ef9bf5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3e00ddf21d407d950d3bd577ef9bf5e">&#9670;&nbsp;</a></span>Sample() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classMPTraits.html">MPTraits</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSamplerMethod.html">SamplerMethod</a>&lt; <a class="el" href="classMPTraits.html">MPTraits</a> &gt;::Sample </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>_numNodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>_maxAttempts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classBoundary.html">Boundary</a> *const&#160;</td>
          <td class="paramname"><em>_boundary</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>_valid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>_invalid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Try to sample a set number of new configurations from a given boundary. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_numNodes</td><td>The number of samples desired. </td></tr>
    <tr><td class="paramname">_maxAttempts</td><td>The maximum number of attempts for each sample. </td></tr>
    <tr><td class="paramname">_boundary</td><td>The boundary to sample from. </td></tr>
    <tr><td class="paramname">_valid</td><td>An iterator to storage for the new configurations. </td></tr>
    <tr><td class="paramname">_invalid</td><td>An (optional) iterator to storage for failed attempts. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa70a536c4082295c4aeb62f64e6e41e2" name="aa70a536c4082295c4aeb62f64e6e41e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa70a536c4082295c4aeb62f64e6e41e2">&#9670;&nbsp;</a></span>Sample() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classMPTraits.html">MPTraits</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSamplerMethod.html">SamplerMethod</a>&lt; <a class="el" href="classMPTraits.html">MPTraits</a> &gt;::Sample </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>_numNodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>_maxAttempts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classBoundary.html">Boundary</a> *const&#160;</td>
          <td class="paramname"><em>_boundary</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>_valid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="afd151326aecad9a60f58f7302252fc0b" name="afd151326aecad9a60f58f7302252fc0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd151326aecad9a60f58f7302252fc0b">&#9670;&nbsp;</a></span>Sample() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classMPTraits.html">MPTraits</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSamplerMethod.html">SamplerMethod</a>&lt; <a class="el" href="classMPTraits.html">MPTraits</a> &gt;::Sample </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>_numNodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>_maxAttempts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classBoundary.html">Boundary</a> *const&#160;</td>
          <td class="paramname"><em>_robotBoundary</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classBoundary.html">Boundary</a> *const&#160;</td>
          <td class="paramname"><em>_eeBoundary</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>_valid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>_invalid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Try to sample a set number of new configurations from a given boundary (for the entire robot), and additionally satisfying a constraint boundary for the end-effector (robot is presumed to have only one EE). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_robotBoundary</td><td>The boundary for the entire robot. </td></tr>
    <tr><td class="paramname">_eeBoundary</td><td>The boundary for the end-effector. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a910e13fb75a521042b4d81adda1897ba" name="a910e13fb75a521042b4d81adda1897ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a910e13fb75a521042b4d81adda1897ba">&#9670;&nbsp;</a></span>Sample() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classMPTraits.html">MPTraits</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSamplerMethod.html">SamplerMethod</a>&lt; <a class="el" href="classMPTraits.html">MPTraits</a> &gt;::Sample </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>_numNodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>_maxAttempts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classBoundary.html">Boundary</a> *const&#160;</td>
          <td class="paramname"><em>_robotBoundary</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classBoundary.html">Boundary</a> *const&#160;</td>
          <td class="paramname"><em>_eeBoundary</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>_valid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >This version does not return invalid samples. This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="a6cee62e80eaee88be4db2eb00fc08af5" name="a6cee62e80eaee88be4db2eb00fc08af5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cee62e80eaee88be4db2eb00fc08af5">&#9670;&nbsp;</a></span>Sample() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classMPTraits.html">MPTraits</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSamplerMethod.html">SamplerMethod</a>&lt; <a class="el" href="classMPTraits.html">MPTraits</a> &gt;::Sample </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>_numNodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>_maxAttempts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classBoundary.html">Boundary</a> *const&#160;</td>
          <td class="paramname"><em>_boundary</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GroupOutputIterator&#160;</td>
          <td class="paramname"><em>_valid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GroupOutputIterator&#160;</td>
          <td class="paramname"><em>_invalid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Try to sample a set number of new configurations from a single boundary. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_numNodes</td><td>The number of samples desired. </td></tr>
    <tr><td class="paramname">_maxAttempts</td><td>The maximum number of attempts for each sample. </td></tr>
    <tr><td class="paramname">_boundary</td><td>The boundary to sample from. </td></tr>
    <tr><td class="paramname">_valid</td><td>An iterator to storage for the new configurations. </td></tr>
    <tr><td class="paramname">_invalid</td><td>An (optional) iterator to storage for failed attempts. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af69f938e5fe535511c1f2711e50b197c" name="af69f938e5fe535511c1f2711e50b197c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af69f938e5fe535511c1f2711e50b197c">&#9670;&nbsp;</a></span>Sample() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classMPTraits.html">MPTraits</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSamplerMethod.html">SamplerMethod</a>&lt; <a class="el" href="classMPTraits.html">MPTraits</a> &gt;::Sample </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>_numNodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>_maxAttempts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classBoundary.html">Boundary</a> *const&#160;</td>
          <td class="paramname"><em>_boundary</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GroupOutputIterator&#160;</td>
          <td class="paramname"><em>_valid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >This version does not return invalid samples. This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="a08debb83ce96bf435c410eb1a5fb28df" name="a08debb83ce96bf435c410eb1a5fb28df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08debb83ce96bf435c410eb1a5fb28df">&#9670;&nbsp;</a></span>Sample() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classMPTraits.html">MPTraits</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSamplerMethod.html">SamplerMethod</a>&lt; <a class="el" href="classMPTraits.html">MPTraits</a> &gt;::Sample </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>_numNodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>_maxAttempts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSamplerMethod.html#a4540a2cc61ca8994b9beb6814a9ec4d3">BoundaryMap</a> &amp;&#160;</td>
          <td class="paramname"><em>_boundary</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GroupOutputIterator&#160;</td>
          <td class="paramname"><em>_valid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GroupOutputIterator&#160;</td>
          <td class="paramname"><em>_invalid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Try to sample a set number of new configurations from a boundary for each robot. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_numNodes</td><td>The number of samples desired. </td></tr>
    <tr><td class="paramname">_maxAttempts</td><td>The maximum number of attempts for each sample. </td></tr>
    <tr><td class="paramname">_boundaryMap</td><td>A map from robot to sampling boundary. Any robots which are not found in the map will use the environment boundary. </td></tr>
    <tr><td class="paramname">_valid</td><td>An iterator to storage for the new configurations. </td></tr>
    <tr><td class="paramname">_invalid</td><td>An (optional) iterator to storage for failed attempts. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a45b69b0c7d464393e0f7f17297a3c9da" name="a45b69b0c7d464393e0f7f17297a3c9da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45b69b0c7d464393e0f7f17297a3c9da">&#9670;&nbsp;</a></span>Sample() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classMPTraits.html">MPTraits</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSamplerMethod.html">SamplerMethod</a>&lt; <a class="el" href="classMPTraits.html">MPTraits</a> &gt;::Sample </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>_numNodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>_maxAttempts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSamplerMethod.html#a4540a2cc61ca8994b9beb6814a9ec4d3">BoundaryMap</a> &amp;&#160;</td>
          <td class="paramname"><em>_boundary</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GroupOutputIterator&#160;</td>
          <td class="paramname"><em>_valid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >This version does not return invalid samples. This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="ad96d5ca883ae4f3926556c356b9e8aea" name="ad96d5ca883ae4f3926556c356b9e8aea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad96d5ca883ae4f3926556c356b9e8aea">&#9670;&nbsp;</a></span>Filter() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classMPTraits.html">MPTraits</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSamplerMethod.html">SamplerMethod</a>&lt; <a class="el" href="classMPTraits.html">MPTraits</a> &gt;::Filter </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>_first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>_last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>_maxAttempts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classBoundary.html">Boundary</a> *const&#160;</td>
          <td class="paramname"><em>_boundary</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>_valid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>_invalid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Apply the sampler rule to a set of existing configurations. The output will generally be a filtered or perturbed version of the input set. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_first</td><td>An iterator to the beginning of a list of input configurations. </td></tr>
    <tr><td class="paramname">_last</td><td>An iterator to the end of a list of input configurations. </td></tr>
    <tr><td class="paramname">_maxAttempts</td><td>The maximum number of attempts to successfully apply the sampler rule to each input. </td></tr>
    <tr><td class="paramname">_boundary</td><td>The sampling boundary to use. </td></tr>
    <tr><td class="paramname">_valid</td><td>An iterator to storage for the output configurations. </td></tr>
    <tr><td class="paramname">_invalid</td><td>An (optional) iterator to storage for failed attempts. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abe709354d7aba5a4af4abd10dafc16a9" name="abe709354d7aba5a4af4abd10dafc16a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe709354d7aba5a4af4abd10dafc16a9">&#9670;&nbsp;</a></span>Filter() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classMPTraits.html">MPTraits</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSamplerMethod.html">SamplerMethod</a>&lt; <a class="el" href="classMPTraits.html">MPTraits</a> &gt;::Filter </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>_first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>_last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>_maxAttempts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classBoundary.html">Boundary</a> *const&#160;</td>
          <td class="paramname"><em>_boundary</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>_valid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >This version does not return invalid samples. This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="a871ccd29e379eb45afa651339770fe43" name="a871ccd29e379eb45afa651339770fe43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a871ccd29e379eb45afa651339770fe43">&#9670;&nbsp;</a></span>Filter() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classMPTraits.html">MPTraits</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSamplerMethod.html">SamplerMethod</a>&lt; <a class="el" href="classMPTraits.html">MPTraits</a> &gt;::Filter </td>
          <td>(</td>
          <td class="paramtype">GroupInputIterator&#160;</td>
          <td class="paramname"><em>_first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GroupInputIterator&#160;</td>
          <td class="paramname"><em>_last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>_maxAttempts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classBoundary.html">Boundary</a> *const&#160;</td>
          <td class="paramname"><em>_boundary</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GroupOutputIterator&#160;</td>
          <td class="paramname"><em>_valid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GroupOutputIterator&#160;</td>
          <td class="paramname"><em>_invalid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Apply the sampler rule to a set of existing configurations. The output will generally be a filtered or perturbed version of the input set. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_first</td><td>An iterator to the beginning of a list of input configurations. </td></tr>
    <tr><td class="paramname">_last</td><td>An iterator to the end of a list of input configurations. </td></tr>
    <tr><td class="paramname">_maxAttempts</td><td>The maximum number of attempts to successfully apply the sampler rule to each input. </td></tr>
    <tr><td class="paramname">_boundary</td><td>The sampling boundary to use. </td></tr>
    <tr><td class="paramname">_valid</td><td>An iterator to storage for the output configurations. </td></tr>
    <tr><td class="paramname">_invalid</td><td>An (optional) iterator to storage for failed attempts. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7361d04bf4e87dad173f5017f4fdd486" name="a7361d04bf4e87dad173f5017f4fdd486"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7361d04bf4e87dad173f5017f4fdd486">&#9670;&nbsp;</a></span>Filter() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classMPTraits.html">MPTraits</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSamplerMethod.html">SamplerMethod</a>&lt; <a class="el" href="classMPTraits.html">MPTraits</a> &gt;::Filter </td>
          <td>(</td>
          <td class="paramtype">GroupInputIterator&#160;</td>
          <td class="paramname"><em>_first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GroupInputIterator&#160;</td>
          <td class="paramname"><em>_last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>_maxAttempts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classBoundary.html">Boundary</a> *const&#160;</td>
          <td class="paramname"><em>_boundary</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GroupOutputIterator&#160;</td>
          <td class="paramname"><em>_valid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="a513d553fce6ead8a4d96bea7a781c82e" name="a513d553fce6ead8a4d96bea7a781c82e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a513d553fce6ead8a4d96bea7a781c82e">&#9670;&nbsp;</a></span>Sampler() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classMPTraits.html">MPTraits</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classSamplerMethod.html">SamplerMethod</a>&lt; <a class="el" href="classMPTraits.html">MPTraits</a> &gt;::Sampler </td>
          <td>(</td>
          <td class="paramtype">CfgType &amp;&#160;</td>
          <td class="paramname"><em>_cfg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classBoundary.html">Boundary</a> *const&#160;</td>
          <td class="paramname"><em>_robotBoundary</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classBoundary.html">Boundary</a> *const&#160;</td>
          <td class="paramname"><em>_eeBoundary</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; CfgType &gt; &amp;&#160;</td>
          <td class="paramname"><em>_valid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; CfgType &gt; &amp;&#160;</td>
          <td class="paramname"><em>_invalid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >This version also specifies a boundary for the end-effector. This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="a09f350ffaec14a28dd2ced1b86ef9d9e" name="a09f350ffaec14a28dd2ced1b86ef9d9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09f350ffaec14a28dd2ced1b86ef9d9e">&#9670;&nbsp;</a></span>Initialize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classMPTraits.html">MPTraits</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classMPBaseObject.html">MPBaseObject</a>&lt; <a class="el" href="classMPTraits.html">MPTraits</a> &gt;::Initialize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Initialize this object for the current <a class="el" href="classMPProblem.html">MPProblem</a>. This should reset any internal state of the algorithms so that they are ready for execution. It is also the place to initialize any state that depends on the current problem. </p><dl class="section warning"><dt>Warning</dt><dd>This member will be called for every compiled algorithm in the planning library - even those that will not be used. If an algorithm needs to do expenisve setup, then this method should only set a flag that tells it to do so on first use. The only exceptions are the MPStrategies, which will only have their initialize called on first use. </dd></dl>

<p>Reimplemented in <a class="el" href="classConnectorMethod.html#a42e2ebe80a645d5ee754afddadac23b0">ConnectorMethod&lt; MPTraits &gt;</a>, <a class="el" href="classCBSQuery.html#ad645c1b5f7619a4abd1d22009da3268d">CBSQuery&lt; MPTraits &gt;</a>, <a class="el" href="classComposeEvaluator.html#a81247b6fd0073ac48bc6b63ebd784c8b">ComposeEvaluator&lt; MPTraits &gt;</a>, <a class="el" href="classLazyQuery.html#aca3602d0e5d6b968dec8ad4e9043d507">LazyQuery&lt; MPTraits &gt;</a>, <a class="el" href="classQueryMethod.html#a7a5d51cb4afaf9d71a736f43cd3ef075">QueryMethod&lt; MPTraits &gt;</a>, <a class="el" href="classSIPPMethod.html#a10dfdf699b4758ed25820084791f03ee">SIPPMethod&lt; MPTraits &gt;</a>, <a class="el" href="classTimeEvaluator.html#ab1a2d8efe7ab6af655f8ac1717a562ab">TimeEvaluator&lt; MPTraits &gt;</a>, <a class="el" href="classTimeMetric.html#a4dbd65fc93ad0f04bc3d7d84cd253678">TimeMetric&lt; MPTraits &gt;</a>, <a class="el" href="classAdaptiveRRT.html#a79477663e138f824f8f9fc1f86e08b31">AdaptiveRRT&lt; MPTraits &gt;</a>, <a class="el" href="classBasicPRM.html#a162f19ebc6e6787d12bd83f9099c8586">BasicPRM&lt; MPTraits &gt;</a>, <a class="el" href="classBasicRRTStrategy.html#aa2d46ff3dae55eb037a657d596dc7d5c">BasicRRTStrategy&lt; MPTraits &gt;</a>, <a class="el" href="classTogglePRMStrategy.html#a2edfd7c6597a9ce049eb603960fed199">TogglePRMStrategy&lt; MPTraits &gt;</a>, <a class="el" href="classValidationStrategy.html#acba79a604ddfb3cb212ba94e55dac924">ValidationStrategy&lt; MPTraits &gt;</a>, <a class="el" href="classLKHSearch.html#a09af580b3c726cdf8bcb02f4fef54485">LKHSearch&lt; MPTraits &gt;</a>, <a class="el" href="classClearanceUtility.html#a47d479bd36819645c5e805b729135634">ClearanceUtility&lt; MPTraits &gt;</a>, <a class="el" href="classReachabilityUtil.html#a4dac67fa30df0d71a43e88b5ad5f74da">ReachabilityUtil&lt; MPTraits &gt;</a>, <a class="el" href="classSafeIntervalTool.html#a3d0e743694e6ff4714bc5cf2dbf94549">SafeIntervalTool&lt; MPTraits &gt;</a>, and <a class="el" href="classTopologicalMap.html#a2c07c15c5990462bf062b9bedc65ebf3">TopologicalMap&lt; MPTraits &gt;</a>.</p>

</div>
</div>
<a id="ab59d82cd734f77fdc17eddb8517461da" name="ab59d82cd734f77fdc17eddb8517461da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab59d82cd734f77fdc17eddb8517461da">&#9670;&nbsp;</a></span>SetName()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classMPTraits.html">MPTraits</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMPBaseObject.html">MPBaseObject</a>&lt; <a class="el" href="classMPTraits.html">MPTraits</a> &gt;::SetName </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>_s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_s</td><td>Class name </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac25ef62edadc2b762f849aa66e2ab66b" name="ac25ef62edadc2b762f849aa66e2ab66b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac25ef62edadc2b762f849aa66e2ab66b">&#9670;&nbsp;</a></span>GetBaseFilename()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classMPTraits.html">MPTraits</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string &amp; <a class="el" href="classMPBaseObject.html">MPBaseObject</a>&lt; <a class="el" href="classMPTraits.html">MPTraits</a> &gt;::GetBaseFilename </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>base file name from <a class="el" href="classMPProblem.html">MPProblem</a> </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>UniformRandomSampler.h</li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.4-->
<!-- start footer part -->
<hr class="footer"/><address class="footer">
<small align="left">PMPL is a project of Texas A&amp;M University</small>
<small align="right">
Generated on Mon Jan 31 2022 14:17:41 for PMPL by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.9.3
</small></address>
</body>
</html>
